\subsection{Algoritmo} \label{sec:algo}
\begin{algorithmic}[0]
  \Procedure{Nome}{$mat[N]$}\Comment{Vetor de matrÃ­culas de tamanho $N$.}
  \State $keys[N] \gets 0$\Comment{Vetor de chaves com tamanho $N$.}
  \State $order \gets$ \Call{SplayTree}{ }
  \State $parent \gets$ \Call{HashTable}{N}
  \State $level \gets$ \Call{HashTable}{N}

  \Statex
  \For{$i \gets 0, N$}
  \State $keys[i] \gets mat[i]$

  \If{$order \neq \emptyset$}
  \State $upper \gets$ \Call{LowerBound}{$order, mat[i]$}
  \If{$upper$ not found}
  \State $w \gets$ \Call{Max}{$order$} \Comment{Maior elemento de $order$.}
  \State $l \gets$ \Call{LookUp}{$level, w+1$} \Comment{$l = level[w+1]$}
  \State \Call{Insert}{$parent, mat[i], w$} \Comment{$parent[mat[i]] = w$}
  \State \Call{Insert}{$level, mat[i], l$}
  \ElsIf{$upper = $ \Call{Min}{$order$}} \Comment{Menor elemento de $order$}
  \State $w \gets$ \Call{Min}{$order$}
  \State $l \gets$ \Call{LookUp}{$level, w+1$}
  \State \Call{Insert}{$parent, mat[i],w$}
  \State \Call{Insert}{$level, mat[i],l$}
  \Else
  \State $y \gets upper$
  \State $lower \gets$ \Call{Previous}{$order, y$} \Comment{Elemento anterior a
    $y$ em $order$}
  \State $z \gets lower$
  \If{\Call{LookUp}{$level, y$} $>$ \Call{LookUp}{$level,z$}}
  \State $l \gets$ \Call{LookUp}{$level, y$}
  \State \Call{Insert}{$parent, mat[i], y$}
  \State \Call{Insert}{$level, mat[i], l+1$}
  \Else
  \State $l \gets$ \Call{LookUp}{$level, z$}
  \State \Call{Insert}{$parent, mat[i], z$}
  \State \Call{Insert}{$level, mat[i], l+1$}
  \EndIf
  \EndIf
  \EndIf
  
  \State \Call{Insert}{$order, mat[i]$}
  \State $i \gets i + 1$
  
  \EndFor
  \EndProcedure
    % \Procedure{Euclid}{$a,b$}\Comment{The g.c.d. of a and b}
    % \State $r\gets a\bmod b$
    % \While{$r\not=0$}\Comment{We have the answer if r is 0}
    %    \State $a\gets b$
    %    \State $b\gets r$
    %    \State $r\gets a\bmod b$
    % \EndWhile\label{euclidendwhile}
    % \State \textbf{return} $b$\Comment{The gcd is b}
    % \EndProcedure
\end{algorithmic}


% \begin{algorithm}[H]
%   \SetAlgoLined
%   \SetKwData{Int}{int}
%   \SetKwFunction{htbl}{HashTable}\SetKwFunction{stree}{SplayTree}
%   \SetKwFunction{read}{Read}\SetKwFunction{empty}{EmptyTree}
  
%   \KwResult{how to write algorithm with \LaTeX2e }
%   \BlankLine
%   keys[100100]\;
%   order $\leftarrow$ \stree{}\;
%   parent $\leftarrow$ \htbl{100100}\;
%   level $\leftarrow$ \htbl{100100}\;
%   \BlankLine
%   n $\leftarrow$ \read{int}\;
%   % \For{$i \leftarrow 0$ \KwTo n}{
%   %   x $\leftarrow$ \read{int}\;
%   %   keys[i] $\leftarrow$ x\;




    
%   % }

  
%   % \While{not at end of this document}{
%   %   read current\;
%   %   \eIf{understand}{
%   %     go to next section\;
%   %     current section becomes this one\;
%   %   }{
%   %     go back to the beginning of current section\;
%   %   }
%   % }
%   \caption{How to write algorithms}
% \end{algorithm}